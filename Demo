import java.awt.Color;
import java.awt.Graphics;
import java.awt.Point;
import java.awt.event.KeyEvent;
import java.awt.event.KeyListener;
import java.util.ArrayList;
import java.util.Collections;

import javax.swing.JFrame;
import javax.swing.JPanel;

public class Pentris extends JPanel {

	private static final long serialVersionUID = -8715353373678321308L;

	private final Point[][][] Pentominoes = {
			// I-Piece
			{
				{ new Point(0, 1), new Point(1, 1), new Point(2, 1), new Point(3, 1),new Point(4, 1) },
				{ new Point(1, 0), new Point(1, 1), new Point(1, 2), new Point(1, 3),new Point(1, 4) },
				{ new Point(0, 1), new Point(1, 1), new Point(2, 1), new Point(3, 1),new Point(4, 1) },
				{ new Point(1, 0), new Point(1, 1), new Point(1, 2), new Point(1, 3),new Point(1, 4) }
			},
			// X-Piece
			{
				{ new Point(0, 1), new Point(1, 1), new Point(1, 0), new Point(1, 2),new Point(2,1) },
				{ new Point(0, 1), new Point(1, 1), new Point(1, 0), new Point(1, 2),new Point(2,1) },
				{ new Point(0, 1), new Point(1, 1), new Point(1, 0), new Point(1, 2),new Point(2,1) },
				{ new Point(0, 1), new Point(1, 1), new Point(1, 0), new Point(1, 2),new Point(2,1) }
			},
			// Z-Piece
			{
				{ new Point(0, 0), new Point(1, 0), new Point(1, 1), new Point(1, 2),new Point(2,2) },
				{ new Point(0, 2), new Point(0, 1), new Point(1, 1), new Point(2, 1),new Point(2,0) },
				{ new Point(0, 2), new Point(1, 2), new Point(1, 1), new Point(1, 0),new Point(2,0) },
				{ new Point(0, 0), new Point(0, 1), new Point(1, 1), new Point(2, 1),new Point(2,2) }
			},
			// V-Piece
			{
				{ new Point(2, 0), new Point(1, 0), new Point(0, 0), new Point(0, 1),new Point(0,2) },
				{ new Point(0, 0), new Point(0, 1), new Point(0, 2), new Point(1, 2),new Point(2,2) },
				{ new Point(0, 0), new Point(1, 0), new Point(2, 0), new Point(2, 1),new Point(2,2) },
				{ new Point(0, 2), new Point(1, 2), new Point(2, 2), new Point(2, 1),new Point(2,0) }
			},
			// T-Piece
			{
				{ new Point(0, 2), new Point(1, 2), new Point(2, 2), new Point(1, 1),new Point(1,0) },
				{ new Point(0, 0), new Point(0, 1), new Point(0, 2), new Point(1, 1),new Point(2,1) },
				{ new Point(0, 0), new Point(1, 0), new Point(2, 0), new Point(1, 1),new Point(1,2) },
				{ new Point(0, 1), new Point(1, 1), new Point(2, 1), new Point(2, 2),new Point(2,0) }
			},	
			// W-Piece
			{
				{ new Point(0, 2), new Point(0, 1), new Point(1, 1), new Point(1, 0),new Point(2,0) },
				{ new Point(0, 0), new Point(1, 0), new Point(1, 1), new Point(2, 1),new Point(2,2) },
				{ new Point(0, 2), new Point(1, 2), new Point(1, 1), new Point(2, 1),new Point(2,0) },
				{ new Point(0, 0), new Point(0, 1), new Point(1, 1), new Point(1, 2),new Point(2,2) }
			},
			// U-Piece
			{
				{ new Point(0, 1), new Point(0, 0), new Point(1, 0), new Point(2, 0),new Point(2,1) },
				{ new Point(0, 0), new Point(1, 0), new Point(1, 1), new Point(1, 2),new Point(0,2) },
				{ new Point(0, 0), new Point(0, 1), new Point(1, 1), new Point(2, 1),new Point(2,0) },
				{ new Point(0, 0), new Point(1, 0), new Point(0, 1), new Point(0, 2),new Point(1,2) }
			},
			
			// MirrorL-Piece
			{
				{ new Point(0, 0), new Point(1, 0), new Point(1, 1), new Point(1, 2),new Point(1,3) },
				{ new Point(0, 1), new Point(1, 1), new Point(2, 1), new Point(3, 1),new Point(3,0) },
				{ new Point(0, 0), new Point(0, 1), new Point(0, 2), new Point(0, 3),new Point(1,3) },
				{ new Point(0, 1), new Point(0, 0), new Point(1, 0), new Point(2, 0),new Point(3,0) }
			},
			
			// L-Piece
			{
				{ new Point(0, 0), new Point(1, 0), new Point(0, 1), new Point(0, 2),new Point(0,3) },
				{ new Point(0, 0), new Point(1, 0), new Point(2, 0), new Point(3, 0),new Point(3,1) },
				{ new Point(0, 3), new Point(1, 3), new Point(1, 2), new Point(1, 1),new Point(1,0) },
				{ new Point(0, 0), new Point(0, 1), new Point(1, 1), new Point(2, 1),new Point(3,1) }
			},
			// N-Piece
			{
				{ new Point(0, 0), new Point(1, 0), new Point(2, 0), new Point(2, 1),new Point(3,1) },
				{ new Point(0, 3), new Point(0, 2), new Point(1, 2), new Point(1, 1),new Point(1,0) },
				{ new Point(0, 0), new Point(1, 0), new Point(1, 1), new Point(2, 1),new Point(3,1) },
				{ new Point(0, 3), new Point(0, 2), new Point(0, 1), new Point(1, 1),new Point(1,0) }
			},
			// MirrorN-Piece
			{
				{ new Point(0, 1), new Point(1, 1), new Point(1, 0), new Point(2, 0),new Point(3,0) },
				{ new Point(0, 0), new Point(0, 1), new Point(1, 1), new Point(1, 2),new Point(1,3) },
				{ new Point(0, 1), new Point(1, 1), new Point(2, 1), new Point(2, 0),new Point(3,0) },
				{ new Point(0, 0), new Point(0, 1), new Point(0, 2), new Point(1, 2),new Point(1,3) }
			},
			// Y-Piece
			{
				{ new Point(0, 0), new Point(1, 0), new Point(2, 0), new Point(2, 1),new Point(3,0) },
				{ new Point(0, 2), new Point(1, 0), new Point(1, 1), new Point(1, 2),new Point(1,3) },
				{ new Point(0, 1), new Point(1, 1), new Point(1, 0), new Point(2, 1),new Point(3,1) },
				{ new Point(0, 0), new Point(0, 1), new Point(1, 1), new Point(0, 2),new Point(0,3) }
			},
			// MirrorY-Piece
			{
				{ new Point(0, 1), new Point(1, 1), new Point(2, 1), new Point(2, 0),new Point(3,1) },
				{ new Point(0, 0), new Point(0, 1), new Point(0, 2), new Point(1, 2),new Point(0,3) },
				{ new Point(0, 0), new Point(1, 0), new Point(1, 1), new Point(2, 0),new Point(3,0) },
				{ new Point(0, 1), new Point(1, 0), new Point(1, 1), new Point(1, 2),new Point(1,3) }
			},
			// F-Piece
			{
				{ new Point(0, 1), new Point(1, 1), new Point(1, 2), new Point(2, 0),new Point(2,1) },
				{ new Point(0, 1), new Point(1, 1), new Point(1, 0), new Point(1, 2),new Point(2,2) },
				{ new Point(0, 2), new Point(0, 1), new Point(1, 1), new Point(1, 0),new Point(2,1) },
				{ new Point(0, 0), new Point(1, 0), new Point(1, 1), new Point(1, 2),new Point(2,1) }
			},
			// MirrorF-Piece
			{
				{ new Point(0, 1), new Point(1, 1), new Point(1, 0), new Point(2, 1),new Point(2,2) },
				{ new Point(0, 2), new Point(1, 2), new Point(1, 1), new Point(1, 0),new Point(2,1) },
				{ new Point(0, 0), new Point(0, 1), new Point(1, 1), new Point(1, 2),new Point(2,1) },
				{ new Point(0, 1), new Point(1, 1), new Point(1, 2), new Point(1, 0),new Point(2,0) }
			},
			// P-Piece
			{
				{ new Point(0, 0), new Point(0, 1), new Point(0, 2), new Point(1, 1),new Point(1,2) },
				{ new Point(0, 0), new Point(1, 0), new Point(2, 0), new Point(1, 1),new Point(0,1) },
				{ new Point(0, 0), new Point(1, 0), new Point(1, 1), new Point(1, 2),new Point(0,1) },
				{ new Point(0, 1), new Point(1, 1), new Point(2, 1), new Point(1, 0),new Point(2,0) }
			},
			// MirrorP-Piece
			{
				{ new Point(0, 2), new Point(0, 1), new Point(1, 0), new Point(1, 1),new Point(1,2) },
				{ new Point(0, 0), new Point(0, 1), new Point(1, 0), new Point(1, 1),new Point(2,1) },
				{ new Point(0, 2), new Point(0, 1), new Point(0, 0), new Point(1, 1),new Point(1,0) },
				{ new Point(0, 0), new Point(1, 0), new Point(2, 0), new Point(1, 1),new Point(2,1) }
			}
			
					
	};
	
	private final Color[] PentominoColors = {
		 new Color(200,0,0),
         new Color(150,150,255),
         new Color(0,200,200),
         new Color(255,150,255),
         new Color(0,200,0),
         new Color(150,255,255),
         new Color(200,200,0),
         new Color(200,255,100),
         new Color(0,55,10),
         new Color(200,55,75),
         new Color(75,55,75),
         new Color(0,135,75),
         new Color(230,150,75),
         new Color(23,15,75),
         new Color(95,210,05),
         new Color(18,50,75),
         new Color(185,95,75),
	};
	
	private Point pieceOrigin;
	private int currentPiece;
	private int rotation;
	private ArrayList<Integer> nextPieces = new ArrayList<Integer>();

	private long score;
	private Color[][] Board;
	
	// Creates a border 
	private void init() {
		Board = new Color[12][24];
		for (int i = 0; i < 12; i++) {
			for (int j = 0; j < 23; j++) {
				if (i == 0 || i == 11 || j == 22) {
					Board[i][j] = Color.GRAY;
				} else {
					Board[i][j] = Color.BLACK;
				}
			}
		}
		newPiece();
	}
	
	// Puts new Piece
	public void newPiece() {
		pieceOrigin = new Point(5, 2);
		rotation = 0;
		if (nextPieces.isEmpty()) {
			Collections.addAll(nextPieces, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17);
			Collections.shuffle(nextPieces);
		}
		currentPiece = nextPieces.get(0);
		nextPieces.remove(0);
	}
	
	// Collision test for the dropping piece
	private boolean collidesAt(int x, int y, int rotation) {
		for (Point p : Pentominoes[currentPiece][rotation]) {
			if (Board[p.x + x][p.y + y] != Color.BLACK) {
				return true;
			}
		}
		return false;
	}
	
	// Rotate the piece clockwise or counterclockwise
	public void rotate(int i) {
		int newRotation = (rotation + i) % 4;
		if (newRotation < 0) {
			newRotation = 3;
		}
		if (!collidesAt(pieceOrigin.x, pieceOrigin.y, newRotation)) {
			rotation = newRotation;
		}
		repaint();
	}
	
	// Move the piece left or right
	public void move(int i) {
		if (!collidesAt(pieceOrigin.x + i, pieceOrigin.y, rotation)) {
			pieceOrigin.x += i;	
		}
		repaint();
	}
	
	// Drops the piece one line or fixes it to the Board if it can't drop
	public void dropDown() {
		if (!collidesAt(pieceOrigin.x, pieceOrigin.y + 1, rotation)) {
			pieceOrigin.y += 1;
		} else {
			fixToWell();
		}	
		repaint();
	}
	
	// Make the dropping piece part of the Board, so it is available for
	// collision detection.
	public void fixToWell() {
		for (Point p : Pentominoes[currentPiece][rotation]) {
			Board[pieceOrigin.x + p.x][pieceOrigin.y + p.y] = PentominoColors[currentPiece];
		}
		clearRows();
		newPiece();
	}
	
	public void deleteRow(int row) {
		for (int j = row-1; j > 0; j--) {
			for (int i = 1; i < 11; i++) {
				Board[i][j+1] = Board[i][j];
			}
		}
	}
	
	// Clear completed rows from the field and award score according to
	// the number of simultaneously cleared rows.
	public void clearRows() {
		boolean gap;
		int numClears = 0;
		
		for (int j = 21; j > 0; j--) {
			gap = false;
			for (int i = 1; i < 11; i++) {
				if (Board[i][j] == Color.BLACK) {
					gap = true;
					break;
				}
			}
			if (!gap) {
				deleteRow(j);
				j += 1;
				numClears += 1;
			}
		}
		
		switch (numClears) {
		case 1:
			score += 100;
			break;
		case 2:
			score += 300;
			break;
		case 3:
			score += 500;
			break;
		case 4:
			score += 800;
			break;
		}
	}
	
	// Draw the falling piece
	private void drawPiece(Graphics g) {		
		g.setColor(PentominoColors[currentPiece]);
		for (Point p : Pentominoes[currentPiece][rotation]) {
			g.fillRect((p.x + pieceOrigin.x) * 26, 
					   (p.y + pieceOrigin.y) * 26, 
					   25, 25);
		}
	}
	
	@Override 
	public void paintComponent(Graphics g)
	{
		// Paint the Board
		g.fillRect(0, 0, 26*12, 26*23);
		for (int i = 0; i < 12; i++) {
			for (int j = 0; j < 23; j++) {
				g.setColor(Board[i][j]);
				g.fillRect(26*i, 26*j, 25, 25);
			}
		}
		
		// Display the score
		g.setColor(Color.WHITE);
		g.drawString("" + score, 19*12, 25);
		
		// Draw the currently falling piece
		drawPiece(g);
	}

	public static void main(String[] args) {
		JFrame f = new JFrame("Tetris");
		f.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
		f.setSize(12*26+10, 26*23+25);
		f.setVisible(true);
		
		final Pentris game = new Pentris();
		game.init();
		f.add(game);
		
		// Keyboard controls
		f.addKeyListener(new KeyListener() {
			public void keyTyped(KeyEvent e) {
			}
			
			public void keyPressed(KeyEvent e) {
				switch (e.getKeyCode()) {
				case KeyEvent.VK_UP:
					game.rotate(-1);
					break;
				case KeyEvent.VK_DOWN:
					game.rotate(+1);
					break;
				case KeyEvent.VK_LEFT:
					game.move(-1);
					break;
				case KeyEvent.VK_RIGHT:
					game.move(+1);
					break;
				case KeyEvent.VK_SPACE:
					game.dropDown();
					game.score += 1;
					break;
				} 
			}
			
			public void keyReleased(KeyEvent e) {
			}
		});
		
		// Make the falling piece drop every second
		new Thread() {
			@Override public void run() {
				while (true) {
					try {
						Thread.sleep(1000);
						game.dropDown();
					} catch ( InterruptedException e ) {}
				}
			}
		}.start();
	}
}
